# -*- coding: utf-8 -*-
"""
Prompt 模板常量。

包含：
- AGENT_*_PROMPT_TEMPLATE: Agent 各阶段 Prompt
- THINK_*_PROMPT_TEMPLATE: Think 模式 Prompt
- 其他辅助 Prompt
"""

from typing import Final

AGENT_ROUTE_PROMPT_TEMPLATE: Final = (
    "你是一个本地桌宠 Agent 的「模式路由器」。\n"
    "你需要判断用户输入更像：\n"
    "- chat：普通对话/闲聊/解释/提问，只需要自然语言回答，不需要执行计划。\n"
    "- do：需要执行任务（写文件/跑命令/使用工具/规划步骤/检索外部信息等），应该启用 plan+ReAct。\n"
    "- think：复杂/开放任务，需要深度思考或多方案对比，需要多模型协作头脑风暴。\n"
    "\n"
    "当用户要求实时/外部事实（天气、新闻、价格、网址内容等）时，优先选择 do（便于使用工具获取）。\n"
    "当用户只是闲聊或问概念性问题，选择 chat。\n"
    "当任务涉及系统设计、架构规划、复杂分析、需要多角度权衡时，选择 think。\n"
    "\n"
    "只输出 JSON（不要代码块、不要解释）：\n"
    "{{\"mode\":\"chat|do|think\",\"confidence\":0.0,\"reason\":\"简短原因\"}}\n"
    "\n"
    "用户输入：\n"
    "{message}"
)

ASSISTANT_OUTPUT_STYLE_GUIDE: Final = (
    "输出格式规范（面向用户可读）：\n"
    "0) 所有对用户可见的文本使用 Markdown（不要输出 HTML）。\n"
    "1) 先给结论/结果（1-3 行）。\n"
    "2) 需要列步骤时用 - 作为项目符号；避免大段连续文本。\n"
    "3) 文件路径/命令/关键参数用反引号包裹，例如 `backend/src/main.py`、`python -m ...`。\n"
    "4) 不要原样粘贴长日志；只保留必要片段。\n"
    "5) 不要声称“已创建文件/已运行测试/已验证成功”，除非你确实执行过 shell_command 或 file_write 并在观测里有证据；未验证就明确写“未验证”，并给出可复现的验证命令。\n"
)


LLM_CHAT_OUTPUT_SYSTEM_PROMPT: Final = (
    "你是一个本地桌宠的对话助手。\n"
    "要求：\n"
    "- 使用 Markdown 输出（不要输出 HTML）。\n"
    "- 回答尽量简短、直接；需要列点时用 - 项目符号。\n"
    "- 路径/命令/关键参数用反引号包裹，便于复制。\n"
)


GRAPH_LLM_PROMPT_TEMPLATE: Final = (
    "请从以下文本中抽取知识图谱，输出 JSON，格式为："
    "{{\"nodes\":[{{\"label\":\"实体\",\"node_type\":\"类型\",\"attributes\":{{}},\"evidence\":\"\"}}],"
    "\"edges\":[{{\"source\":\"实体A\",\"target\":\"实体B\",\"relation\":\"关系\",\"confidence\":0.5,\"evidence\":\"\"}}]}}。"
    "要求：source/target 使用实体 label；仅输出 JSON，不要多余文字。文本：\n{content}"
)

AGENT_DOMAIN_PICK_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的领域筛选器。\n"
    "给定用户任务与领域列表，请挑选最相关的领域（最多 {max_domains} 个）。\n"
    "只输出 JSON（不要代码块、不要解释）：{{\"domain_ids\":[\"data\",\"web\"]}}\n"
    "规则：\n"
    "1) 优先选择与任务直接相关的领域（例如：数据处理任务选 data.*，网页抓取选 web.*）。\n"
    "2) 若任务跨多个领域，选择最相关的 1-3 个领域。\n"
    "3) 若没有合适领域或任务属于通用类型，输出 [\"misc\"]。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "相关知识图谱（GRAG，可为空）：\n"
    "{graph}\n"
    "\n"
    "领域列表（domain_id. name - description）：\n"
    "{domains}\n"
)


KNOWLEDGE_SUFFICIENCY_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的知识充分性评估器。\n"
    "给定用户任务和检索到的知识，请判断当前知识是否足以支撑任务规划。\n"
    "只输出 JSON（不要代码块、不要解释）：\n"
    "{{\"sufficient\":true/false,\"reason\":\"简短原因\",\"missing_knowledge\":\"缺失的知识类型（如有）\",\"suggestion\":\"建议动作（如有）\"}}\n"
    "\n"
    "判断规则：\n"
    "1) sufficient=true：当前知识足以直接规划执行（有相关技能/方案可参考，或任务足够简单无需特定知识）。\n"
    "2) sufficient=false：需要额外知识（如：缺少关键技能、缺少领域方法论、需要组合多个技能）。\n"
    "3) missing_knowledge 取值：skill（缺技能）、methodology（缺方法论）、tool（缺工具）、domain_knowledge（缺领域知识）、none（无缺失）。\n"
    "4) suggestion 取值：proceed（直接规划）、compose_skills（组合已有技能）、create_draft_skill（创建草稿技能）、ask_user（询问用户）。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "检索到的技能（{skill_count} 个）：\n"
    "{skills}\n"
    "\n"
    "检索到的图谱节点（{graph_count} 个）：\n"
    "{graph}\n"
    "\n"
    "检索到的记忆（{memory_count} 个）：\n"
    "{memories}\n"
)

SKILL_COMPOSE_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的技能组合器。\n"
    "给定用户任务和可用技能列表，请组合这些技能生成一个新的复合技能来完成任务。\n"
    "只输出 JSON（不要代码块、不要解释）：\n"
    "{{\"name\":\"技能名称\",\"description\":\"技能描述\",\"steps\":[\"步骤1\",\"步骤2\"],\"source_skills\":[id1,id2],\"domain_id\":\"领域ID\"}}\n"
    "\n"
    "组合规则：\n"
    "1) name：简洁描述组合后技能的核心功能（如：数据抓取与分析）。\n"
    "2) description：详细描述组合后技能的适用场景和能力。\n"
    "3) steps：将源技能的步骤重新组织，形成连贯的执行流程。\n"
    "4) source_skills：记录组合所使用的源技能 ID 列表。\n"
    "5) domain_id：根据任务类型选择最合适的领域（如 data、web、finance 等）。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "可用技能列表：\n"
    "{skills}\n"
)

SKILL_DRAFT_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的技能草拟器。\n"
    "当检索到的技能不足以支撑任务规划时，你需要基于“用户任务 + 图谱约束 + 已命中的技能候选”草拟一个 draft 技能（methodology），\n"
    "用于当前任务的规划参考（不要求完美，执行后会被真实执行记录覆盖/升级）。\n"
    "\n"
    "只输出 JSON（不要代码块、不要解释）：\n"
    "{{\"name\":\"技能名称\",\"description\":\"技能描述\",\"steps\":[\"步骤1\",\"步骤2\"]}}\n"
    "\n"
    "规则：\n"
    "1) name：概括该技能能解决的问题类型。\n"
    "2) description：写清适用场景、输入输出与边界。\n"
    "3) steps：给出 3-8 条可执行的抽象步骤（偏方法论，不要写具体文件名）。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "图谱约束（可为空）：\n"
    "{graph}\n"
    "\n"
    "已命中的技能（可为空）：\n"
    "{skills}\n"
)


AGENT_GRAPH_PICK_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的知识图谱检索器（GRAG）。\n"
    "给定用户任务与图谱节点列表，请挑选最相关的节点（最多 {max_nodes} 个）。\n"
    "只输出 JSON（不要代码块、不要解释）：{{\"node_ids\":[1,2]}}\n"
    "规则：\n"
    "1) 优先选择能直接影响当前任务的事实/约束/依赖（例如：路径、接口约定、已验证结论、用户偏好）。\n"
    "2) 若没有合适节点，输出空数组。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "图谱节点列表（id. label - type/evidence）：\n"
    "{nodes}\n"
)


AGENT_SKILL_PICK_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的技能检索器。\n"
    "给定用户任务与技能列表，请挑选最相关的技能（最多 {max_skills} 个）。\n"
    "只输出 JSON（不要代码块、不要解释）：{{\"skill_ids\":[1,2]}}\n"
    "规则：\n"
    "1) 仅选择能直接指导“怎么做”的技能（尤其是：如何用工具/命令获取外部信息、如何验证结果）。\n"
    "2) 若没有合适技能，输出空数组。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "技能列表（id. name - description）：\n"
    "{skills}\n"
)

AGENT_SOLUTION_PICK_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的方案检索器。\n"
    "给定用户任务与方案列表，请挑选最相关的方案（最多 {max_solutions} 个）。\n"
    "只输出 JSON（不要代码块、不要解释）：{{\"solution_ids\":[1,2]}}\n"
    "规则：\n"
    "1) 选择能直接复用的完整流程（包括：关键步骤顺序、工具使用、验证方式）。\n"
    "2) 若没有合适方案，输出空数组。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "方案列表（id. name - description/metadata）：\n"
    "{solutions}\n"
)

AGENT_SOLUTION_DRAFT_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的方案草拟器。\n"
    "当没有匹配到可复用方案时，你需要基于“用户任务 + 已命中的技能 + 可用工具清单 + 图谱约束”草拟一个 draft 方案，\n"
    "用于后续生成 plan（plan 会以该方案作为参考，不要求完全一致）。\n"
    "\n"
    "只输出 JSON（不要代码块、不要解释）：\n"
    "{{\"name\":\"...\",\"description\":\"...\",\"steps\":[{{\"title\":\"...\",\"allow\":[\"action_type\"]}}],\"artifacts\":[\"relative/path\"],\"tool_names\":[\"tool_name\"]}}\n"
    "\n"
    "规则：\n"
    "1) steps 最多 {max_steps} 步；每步必须有 title。\n"
    "2) title 建议使用动作前缀：file_write: / file_read: / file_list: / file_append: / file_delete: / tool_call: / shell_command: / http_request: / llm_call: / json_parse: / user_prompt: / task_output。\n"
    "3) allow 仅允许这些 action_type：file_write,file_read,file_list,file_append,file_delete,tool_call,shell_command,http_request,llm_call,memory_write,json_parse,user_prompt,task_output。\n"
    "4) artifacts 仅列出需要落盘的相对路径（可为空）。\n"
    "5) 若需要调用已有工具，优先用 tool_call，并把工具名写入 tool_names（便于后续工具优先注入）；tool_names 可为空。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "图谱约束（可为空）：\n"
    "{graph}\n"
    "\n"
    "相关技能（可为空）：\n"
    "{skills}\n"
    "\n"
    "可用工具（优先复用）：\n"
    "{tools}\n"
)


AGENT_MEMORY_PICK_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的记忆检索器。\n"
    "给定用户任务与记忆列表，请挑选最相关的记忆（最多 {max_items} 条）。\n"
    "只输出 JSON（不要代码块、不要解释）：{{\"memory_ids\":[1,2]}}\n"
    "规则：\n"
    "1) 优先选择能影响当前任务的长期信息：用户偏好/配置/Base URL/API Key 是否已配置/常用路径/已确认事实。\n"
    "2) 若没有合适记忆，输出空数组。\n"
    "\n"
    "用户任务：\n"
    "{message}\n"
    "\n"
    "记忆列表（id. content - tags/type）：\n"
    "{memories}\n"
)


AGENT_PLAN_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent，需要把用户指令拆成一个“可执行计划(plan)”。\n"
    "先阅读“相关知识图谱/相关记忆/相关技能”，优先复用已有方法与既有上下文（例如如何用工具抓取 URL 内容、用户偏好、已配置的 Base URL）。\n"
    "注意：当用户要求实时/外部事实（天气、新闻、价格、最新信息）时，不能直接说“无法访问”。\n"
    "你必须把“如何获取信息”纳入计划：优先 tool_call 调用已有工具（如 web_fetch），必要时用 shell_command。\n"
    "如果现有工具不足以完成关键步骤，你必须把“工具自举”纳入计划：\n"
    "- 优先 tool_call 创建新工具（必须带 tool_metadata.exec，output 留空让系统真实执行；禁止在 output 里编造结果）\n"
    "- 然后用一个最小输入自测该工具（例如抓取一个短页面/运行一个小样例），确认输出结构正确\n"
    "- 若工具逻辑较复杂：先用 file_write 写一个小脚本到 `{agent_workspace}`（相对 workdir 的实验目录），再用 tool_call.exec 调用该脚本（例如 args=[\"python\",\"{agent_workspace}/script.py\",\"{{input}}\"]）\n"
    "- 注意：tool_metadata.exec.args 是“要执行的命令 token 列表”，不是“输入参数列表”。\n"
    "  - 不要把 tool_call.input 再写到 exec.args 里（例如 exec.args=[\"GC=F\"] 会导致系统尝试执行 GC=F 这个不存在的命令）。\n"
    "  - 若要把输入传给脚本/命令，请在 exec.command 或 exec.args 中使用占位符 `{{input}}`（系统会替换为 tool_call.input）。\n"
    "- 再用该工具完成任务；自测失败则修复工具或换实现（不要直接停止）\n"
    "\n"
    "相关知识图谱（GRAG，可为空）：\n"
    "{graph}\n"
    "\n"
    "相关记忆（可为空）：\n"
    "{memories}\n"
    "\n"
    "相关技能（可为空）：\n"
    "{skills}\n"
    "\n"
    "相关方案（可为空）：\n"
    "{solutions}\n"
    "\n"
    "可用工具（优先复用）：\n"
    "{tools}\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）。\n"
    "输出格式：\n"
    "{{\n"
    "  \"plan\":[{{\"title\":\"步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}}, ...],\n"
    "  \"artifacts\":[\"相对路径1\",\"相对路径2\"]\n"
    "}}\n"
    "说明：\n"
    "- allow 用于约束执行阶段允许的 action.type（减少“嘴上完成但未执行”的情况），每步必须提供。\n"
    "- artifacts 用于声明本任务预期创建/更新的文件（不涉及文件则输出空数组）。\n"
    "要求：\n"
    "1) plan 数量不超过 {max_steps}。\n"
    "2) title 要短、明确、可执行，并在标题里写清“动作/工具”（例如“tool_call:web_fetch 抓取 目标URL”或“file_write:test/sokoban/index.html 写入页面”）。\n"
    "3) brief 用于 UI 左侧计划栏展示：只写 2-10 个字的总结（不要编号/不要标点/不要包含 tool_call/file_write 前缀/不要 URL）。\n"
    "4) allow 只能从以下 action.type 中选择（建议每步只选 1 个）：\n"
    "   - {action_types_line}\n"
    "5) 对于外部信息任务，建议至少包含：获取数据 -> 校验/必要时重试 -> 总结 -> 输出。\n"
    "   - 为了允许 ReAct 视情况重试，第二步 allow 可同时包含 tool_call 与 llm_call：若观测显示数据为空/无关则继续 tool_call；否则 llm_call 总结。\n"
    "5.1) 若计划中需要“新建工具”（现有工具列表里没有的 tool_name / 或需要新 exec 逻辑），必须安排：创建工具 -> 自测工具 -> 再执行正式抓取/处理。\n"
    "   - 自测工具：用一个最小输入跑通（例如抓取一个短页面/打印版本号），确认输出不为空且结构可解析。\n"
    "   - tool_call.input 必须是非空字符串：创建工具/自测时也要填入最小输入（例如 \"self_test\" / \"ping\" / 示例 URL）。\n"
    "   - 若 tool_metadata.exec 引用本地脚本路径（例如 `{agent_workspace}/gold_fetcher.py`），必须先安排 file_write 创建脚本，再执行 tool_call；脚本放实验目录即可，不必加入 artifacts。\n"
    "6) 对于“生成代码/写文件”任务：\n"
    "   - 必须包含 file_write 步骤，并在 artifacts 列出将创建/更新的文件路径。\n"
    "   - 如果 artifacts 有 N 个文件，则 plan 中至少需要 N 个 allow 包含 file_write 的步骤（每个文件一个步骤）。\n"
    "   - 每个写文件步骤的 title 建议写成 `file_write:相对路径 写入/更新...`，避免后续执行阶段写错文件。\n"
    "   - 若 artifacts 非空，必须在所有 file_write 之后加入“验证步骤”（allow 为 shell_command 或 tool_call），\n"
    "     标题需包含“验证/校验/检查/自测”等关键词（例如：shell_command:验证文件内容）。\n"
    "   - 若数据未获取成功，禁止把“失败说明/错误原因”写入 artifacts；应继续重试或换实现。\n"
    "7) 计划必须包含“输出最终结果”的步骤（例如“输出结论”，allow=task_output）。\n"
    "\n"
    "用户指令：\n"
    "{message}"
)


AGENT_REACT_STEP_PROMPT_TEMPLATE: Final = (
    "你正在执行一个本地 Agent 任务，需要按步骤逐步推进（ReAct）。\n"
    "你只能输出 JSON（不要代码块，不要解释）。\n"
    "\n"
    "可用 action.type：{action_types_line}。\n"
    "payload 规则：\n"
    "- llm_call: prompt(必填), template_id(可选数字), variables, parameters, dry_run（不要写 provider/model）\n"
    "- memory_write: content(必填), memory_type, tags\n"
    "- task_output: output_type(建议 text), content(可为空：仅当你确定上一条 llm_call 已生成可直接输出的结论时；否则必须填写最终结论)\n"
    "- tool_call: tool_id/tool_name..., input(字符串且非空), output(必须留空；系统会执行工具并填充输出), tool_metadata.exec(新建/补全工具时必填), skill_id(可选)\n"
    "- shell_command: command(必填), workdir(必填), timeout_ms(可选)\n"
    "- file_write: path(必填), content(必填), encoding(可选，默认 utf-8)\n"
    "- file_read: path(必填), encoding(可选，默认 utf-8), max_bytes(可选)\n"
    "- file_append: path(必填), content(必填), encoding(可选，默认 utf-8)\n"
    "- file_list: path(必填), pattern(可选), recursive(可选), max_entries(可选)\n"
    "- file_delete: path(必填), recursive(可选)\n"
    "- http_request: url(必填), method, headers, params, data, json, timeout_ms, allow_redirects, encoding, max_bytes\n"
    "- json_parse: text(必填), pick_keys(可选)\n"
    "- user_prompt: question(必填)\n"
    "示例（仅示意）：\n"
    "- llm_call: {{\"prompt\":\"总结以下内容...\"}}\n"
    "- memory_write: {{\"content\":\"用户偏好中文输出\",\"tags\":[\"pref\"]}}\n"
    "- task_output: {{\"output_type\":\"text\",\"content\":\"完成说明...\"}}\n"
    "- tool_call: {{\"tool_name\":\"web_fetch\",\"input\":\"https://example.com\",\"output\":\"\"}}\n"
    "- shell_command: {{\"command\":\"python -c \\\"print(1)\\\"\",\"workdir\":\"{workdir}\"}}\n"
    "- file_write: {{\"path\":\"test/output.txt\",\"content\":\"hello\"}}\n"
    "- file_read: {{\"path\":\"test/output.txt\",\"encoding\":\"utf-8\",\"max_bytes\":2000}}\n"
    "- file_append: {{\"path\":\"test/log.txt\",\"content\":\"ok\\n\"}}\n"
    "- file_list: {{\"path\":\"test\",\"recursive\":false,\"max_entries\":50}}\n"
    "- file_delete: {{\"path\":\"test/output.txt\"}}\n"
    "- http_request: {{\"url\":\"https://example.com/api\",\"method\":\"GET\",\"timeout_ms\":10000}}\n"
    "- json_parse: {{\"text\":\"{{\\\\\"a\\\\\":1}}\",\"pick_keys\":[\"a\"]}}\n"
    "- user_prompt: {{\"question\":\"请提供目标目录\"}}\n"
    "\n"
    "重要规则：\n"
    "1) 如果需要实时/外部信息，优先使用工具获取（tool_call）而不是直接 llm_call。不要回答“无法访问”。\n"
    "   - 内置工具 web_fetch：input 传 URL，output 留空即可（系统会执行 curl 抓取并记录为工具调用）。\n"
    "   - 示例（仅用于天气类任务）：先 tool_call(web_fetch) 抓取 https://wttr.in/Chengdu?format=j1，再 llm_call 总结，再 task_output 输出。\n"
    "     注意：wttr.in 是天气服务，不适用于价格/新闻/金融数据。\n"
    "   - 若抓取结果为空、明显与目标无关，或缺少可验证的数据字段，你必须继续尝试其他来源（必要时用 plan_patch 把下一步改为 tool_call/shell_command 重试），禁止直接编造结论。\n"
    "   - 若列表里没有合适工具，可用 tool_call 创建新工具：提供 tool_name/tool_description/tool_metadata.exec（shell args/timeout），并把 output 留空让系统真实执行。\n"
    "   - 工具自举强约束：当你发现“做不到/拿不到数据/缺能力”时，优先先造工具再继续。\n"
    "     你应该先让工具跑通（自测），再依赖它产出最终结论；若自测失败就修复工具或换实现，禁止直接停在“无法获取”。\n"
    "     若工具逻辑较复杂：先 file_write 写脚本（建议放到 `{agent_workspace}` 这个实验目录下），再 tool_call.exec 调用脚本；不要把复杂逻辑塞进一条超长 shell。\n"
    "     tool_call.input 必须非空；创建工具/自测也要填入最小输入（例如 \"self_test\" / \"ping\" / 目标URL）。\n"
    "     若 tool_metadata.exec 引用本地脚本路径，必须先 file_write 创建该脚本，再执行 tool_call。\n"
    "     自测建议：用 plan_patch.insert_steps 插入 1 个 tool_call 步骤做最小样例输入；确认输出不为空且与目标相关。\n"
    "     禁止在 tool_call.output 里手填/编造结果（output 必须留空，交给系统执行）。\n"
    "   - 重要：exec.args 是“命令 token 列表”，不是“输入参数列表”。\n"
    "     - 正确示例：exec.args=[\"python\",\"-c\",\"print(1)\",\"{{input}}\"] 或 exec.command=\"python -c print(1) {{input}}\"。\n"
    "     - 错误示例：exec.command=\"python -c ...\" 同时 exec.args=[\"GC=F\"]（会被当成要执行的命令导致失败）。\n"
    "2) 只有在确实无法通过工具获取时，才允许解释限制，并给出可行替代方案。\n"
    "2.5) 如果缺少关键信息导致无法继续（例如需要用户确认/补充路径/选择项），你必须使用 user_prompt 询问用户，且问题要具体、可回答。\n"
    "2.6) Windows 提示：shell_command 需要可执行文件；像 dir 这类 cmd 内建命令可能找不到。优先使用 python -c 做目录/文件存在性检查与文本处理。\n"
    "2.7) Windows 提示：python -c 中的路径请使用正斜杠（例如 C:/path/file.csv）或 raw string（r'...')，避免 \\t/\\n 等转义导致路径错误。\n"
    "2.8) 仅当本步骤是计划最后一步时才允许选择 task_output；否则禁止选择 task_output。\n"
    "3) 所有 shell_command 必须把 workdir 设为：{workdir}\n"
    "4) 如果参考了某个技能，请在 tool_call.payload.skill_id 填对应技能 id，便于统计复用效果。\n"
    "5) 对用户可见的文本输出（llm_call.response / task_output.content）请遵循以下规范：\n"
    "{output_style}\n"
    "6) 若执行过程中出现值得长期复用的信息（用户偏好/路径/配置/结论），请用 memory_write 写入 1-3 行简短记忆（避免长段落）。\n"
    "\n"
    "相关知识图谱（GRAG，可为空）：\n"
    "{graph}\n"
    "\n"
    "相关记忆（可能包含用户偏好/环境信息；可为空）：\n"
    "{memories}\n"
    "\n"
    "相关技能（优先复用；若不适用可忽略）：\n"
    "{skills}\n"
    "\n"
    "可用工具列表（优先复用）：\n"
    "{tools}\n"
    "\n"
    "用户目标：{message}\n"
    "总体计划：{plan}\n"
    "当前步骤（第{step_index}步）：{step_title}\n"
    "本步骤允许的 action.type（必须从中选择）：{allowed_actions}\n"
    "已完成观测（最近几条，可能被截断）：\n"
    "{observations}\n"
    "\n"
    "注意：复杂 Python 逻辑（含 try/except/for/def/多行）不要用 python -c；应先 file_write 脚本到实验目录，再用 shell_command 执行。\n"
    "注意：若最近观测包含 FAIL 且尚未修复，请不要选择 task_output。\n"
    "注意：若 artifacts 非空且数据未就绪，禁止把失败说明写入 artifacts。\n"
    "\n"
    "计划修正（可选）：如果你发现“下一步（第 {step_index}+1 步）”需要调整，你可以在顶层附加 plan_patch。\n"
    "- 只允许影响“下一步（第 {step_index}+1 步）”开始的位置；禁止直接修改第 {step_index}+2 及之后的既有步骤。\n"
    "- plan_patch.step_index 必须等于 {step_index}+1。\n"
    "- plan_patch 允许字段：\n"
    "  - title/brief/allow：修改下一步\n"
    "  - insert_steps：在“下一步位置”插入 1..N 个新步骤（会把原来的下一步及其后的步骤整体后移；用于重试/补步骤）\n"
    "  - artifacts_add：追加文件路径（不要覆盖全量 artifacts）\n"
    "  说明：若使用 insert_steps，则会插入你给出的步骤列表；不要同时再依赖 title/brief/allow。\n"
    "  约束：insert_steps 不得包含 task_output；最终输出只能由计划最后一步执行。\n"
    "  约束：insert_steps 中若包含 file_write，title 必须写成 file_write:<相对路径>，并确保路径落在目标目录或 artifacts 内。\n"
    "\n"
    "额外约束：若最近观测里出现 FAIL 且尚未修复，不要选择 task_output；应先修复/重试或通过 plan_patch 补步骤。\n"
    "请输出：{{\"action\":{{\"type\":\"...\",\"payload\":{{...}}}},\"plan_patch\":null}} 或省略 plan_patch。\n"
    "plan_patch 示例（插入两步：重试抓取 + 输出）：\n"
    "{{\"step_index\":2,\"insert_steps\":[\n"
    "  {{\"title\":\"tool_call:web_fetch 抓取备用来源\",\"brief\":\"重试抓取\",\"allow\":[\"tool_call\"]}},\n"
    "  {{\"title\":\"输出结果\",\"brief\":\"输出\",\"allow\":[\"task_output\"]}}\n"
    "],\"artifacts_add\":[],\"reason\":\"...\"}}\n"
)


AGENT_REPLAN_PROMPT_TEMPLATE: Final = (
    "你正在执行一个本地 Agent 任务（Plan-Execute-Replan）。\n"
    "当前执行遇到失败/卡住，需要基于已有计划与已完成步骤重新规划剩余步骤。\n"
    "你只能输出 JSON（不要代码块、不要解释）。\n"
    "\n"
    "输出格式：\n"
    "{{\n"
    "  \"plan\":[{{\"title\":\"步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}}, ...],\n"
    "  \"artifacts\":[\"相对路径1\",\"相对路径2\"]\n"
    "}}\n"
    "\n"
    "规则：\n"
    "1) 只输出“剩余要执行的步骤”，不要重复已完成步骤。\n"
    "2) allow 只能从以下 action.type 中选择：{action_types_line}。\n"
    "3) brief 只写 2-10 个字（不要编号/不要标点/不要 URL）。\n"
    "4) task_output 必须且只能出现在最后一步。\n"
    "5) 如果需要新增工具或修复工具，务必包含“自测步骤”。\n"
    "6) Windows 路径：python -c 中请使用正斜杠或 raw string（r'...')。\n"
    "7) 复杂 Python 逻辑不要用 python -c（含 try/except/for/def/多行）。请先 file_write 到实验目录脚本，再用 shell_command 执行脚本。\n"
    "8) 若要写文件，file_write 的 title 必须写成 file_write:<相对路径>，并与 artifacts/目标目录一致。\n"
    "9) 若 artifacts 非空，必须包含“验证步骤”（allow 为 shell_command 或 tool_call），且标题包含“验证/校验/检查/自测”。\n"
    "10) tool_call.input 必须非空；创建工具/自测也要填入最小输入（例如 \"self_test\" / \"ping\" / 目标URL）。\n"
    "11) 若 tool_metadata.exec 引用本地脚本路径，必须先 file_write 创建该脚本，再执行 tool_call。\n"
    "12) 若数据未获取成功，禁止把失败说明写入 artifacts；应继续重试或换实现。\n"
    "\n"
    "用户目标：{message}\n"
    "当前 workdir：{workdir}\n"
    "实验目录（临时脚本/中间产物）：{agent_workspace}\n"
    "已有计划（titles）：{plan}\n"
    "已完成步骤：{done_steps}\n"
    "当前失败信息：{error}\n"
    "最近观测：\n"
    "{observations}\n"
    "\n"
    "可用工具列表（优先复用）：\n"
    "{tools}\n"
    "\n"
    "相关技能（可为空）：\n"
    "{skills}\n"
    "\n"
    "相关方案（可为空）：\n"
    "{solutions}\n"
    "\n"
    "相关记忆（可为空）：\n"
    "{memories}\n"
    "\n"
    "相关知识图谱（可为空）：\n"
    "{graph}\n"
)

THINK_INITIAL_PLANNING_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的规划者（Planner），正在参与多模型协作规划。\n"
    "你需要基于给定的知识检索结果，为用户任务生成一个可执行计划。\n"
    "注意：你是多个规划者之一，你的方案将与其他规划者的方案一起参与投票。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）。\n"
    "输出格式：\n"
    "{{\n"
    "  \"plan\":[{{\"title\":\"步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}}, ...],\n"
    "  \"artifacts\":[\"相对路径1\",\"相对路径2\"],\n"
    "  \"rationale\":\"简要说明设计理由（30-50字）\"\n"
    "}}\n"
    "\n"
    "规则：\n"
    "1) plan 数量不超过 {max_steps}。\n"
    "2) title 要短、明确、可执行，并在标题里写清「动作/工具」。\n"
    "3) brief 只写 2-10 个字的总结。\n"
    "4) allow 只能从以下 action.type 中选择：{action_types_line}\n"
    "5) rationale 用于向其他规划者解释你的设计思路。\n"
    "6) 对于外部信息任务，必须使用工具获取，不能直接编造。\n"
    "7) task_output 必须是最后一步。\n"
    "\n"
    "你的规划者角色：{planner_role}\n"
    "相关知识图谱（GRAG）：\n{graph}\n"
    "相关技能：\n{skills}\n"
    "相关方案：\n{solutions}\n"
    "可用工具：\n{tools}\n"
    "\n"
    "用户目标：\n{message}\n"
    "当前工作目录：{workdir}\n"
)


THINK_VOTE_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的规划者（Planner），正在参与方案投票。\n"
    "请对以下方案进行评分，并选出你认为最优的方案。\n"
    "注意：{self_vote_rule}\n"
    "\n"
    "评分维度（每项 0-10 分）：\n"
    "- feasibility（可行性）：方案是否切实可行\n"
    "- completeness（完整性）：是否覆盖了任务的所有方面\n"
    "- efficiency（效率）：步骤是否简洁高效\n"
    "- risk（风险控制）：是否考虑了潜在风险和失败处理\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"scores\": [\n"
    "    {{\"plan_id\": 0, \"feasibility\": 8, \"completeness\": 7, \"efficiency\": 9, \"risk\": 6, \"total\": 30, \"comment\": \"简短评语\"}},\n"
    "    ...\n"
    "  ],\n"
    "  \"vote_for\": 0\n"
    "}}\n"
    "\n"
    "用户目标：\n{message}\n"
    "\n"
    "候选方案：\n{plans}\n"
)


THINK_IMPROVE_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的规划者（Planner），你的方案在第一轮投票中未被选中。\n"
    "请参考入选方案的优点，结合你原有的思路，生成一个改进后的方案。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"plan\":[{{\"title\":\"步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}}, ...],\n"
    "  \"artifacts\":[\"相对路径1\",\"相对路径2\"],\n"
    "  \"rationale\":\"说明如何结合了入选方案的优点（30-50字）\",\n"
    "  \"improvements\":\"相比原方案的改进点（20-30字）\"\n"
    "}}\n"
    "\n"
    "你的原方案：\n{original_plan}\n"
    "\n"
    "入选方案（参考）：\n{winning_plan}\n"
    "\n"
    "用户目标：\n{message}\n"
    "当前工作目录：{workdir}\n"
)


THINK_ELABORATE_PROMPT_TEMPLATE: Final = (
    "你的方案在第二轮投票中入选，请详细阐述你的方案。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"step_rationales\": [\n"
    "    {{\"step_index\": 0, \"reason\": \"这一步的设计理由\", \"risks\": \"潜在风险\", \"mitigation\": \"应对措施\"}},\n"
    "    ...\n"
    "  ],\n"
    "  \"dependencies\": [{{\"from_step\": 0, \"to_step\": 1, \"reason\": \"依赖原因\"}}],\n"
    "  \"overall_confidence\": 0.85,\n"
    "  \"key_assumptions\": [\"假设1\", \"假设2\"]\n"
    "}}\n"
    "\n"
    "你的方案：\n{plan}\n"
    "\n"
    "用户目标：\n{message}\n"
)


THINK_REFLECTION_ANALYZE_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的规划者（Planner），正在参与执行失败的反思讨论。\n"
    "请分析失败原因，并提出你的观点。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"root_cause\": \"失败的根本原因（20-40字）\",\n"
    "  \"evidence\": [\"证据1\", \"证据2\"],\n"
    "  \"fix_suggestion\": \"修复建议（30-50字）\",\n"
    "  \"confidence\": 0.8\n"
    "}}\n"
    "\n"
    "执行失败信息：\n{error}\n"
    "\n"
    "执行日志（最近观测）：\n{observations}\n"
    "\n"
    "当前计划：\n{plan}\n"
    "\n"
    "已完成步骤：\n{done_steps}\n"
)


THINK_REFLECTION_VOTE_PROMPT_TEMPLATE: Final = (
    "你是一个本地 Agent 的规划者（Planner），正在对失败分析观点进行投票。\n"
    "请选出你认为最准确的失败分析。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"scores\": [\n"
    "    {{\"analysis_id\": 0, \"accuracy\": 8, \"actionability\": 7, \"total\": 15, \"comment\": \"简短评语\"}},\n"
    "    ...\n"
    "  ],\n"
    "  \"vote_for\": 0\n"
    "}}\n"
    "\n"
    "候选分析：\n{analyses}\n"
)


THINK_REFLECTION_FIX_PROMPT_TEMPLATE: Final = (
    "你的失败分析在投票中被选中，请基于你的分析生成修复步骤。\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"insert_steps\": [\n"
    "    {{\"title\":\"修复步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}},\n"
    "    ...\n"
    "  ],\n"
    "  \"reason\": \"修复思路说明（30-50字）\"\n"
    "}}\n"
    "\n"
    "规则：\n"
    "1) insert_steps 数量为 1..{max_steps}。\n"
    "2) allow 只能从以下 action.type 中选择：{action_types_line}\n"
    "3) insert_steps 不得包含 task_output。\n"
    "\n"
    "你的失败分析：\n{analysis}\n"
    "\n"
    "当前计划：\n{plan}\n"
    "\n"
    "用户目标：\n{message}\n"
)


THINK_EXECUTOR_ASSIGN_PROMPT_TEMPLATE: Final = (
    "请为以下计划步骤分配执行者（Executor）。\n"
    "\n"
    "可用执行者角色：\n"
    "- executor_code：负责代码编写、脚本执行、工具调用\n"
    "- executor_doc：负责文档编写、说明文本\n"
    "- executor_test：负责测试验证、结果检查\n"
    "\n"
    "分配规则：\n"
    "- file_write（代码文件）→ executor_code\n"
    "- file_write（文档/说明）→ executor_doc\n"
    "- shell_command → executor_code\n"
    "- tool_call → executor_code\n"
    "- llm_call（验证类）→ executor_test\n"
    "- task_output → 由最后完成者负责\n"
    "\n"
    "请严格只输出 JSON（不要代码块、不要解释文字）：\n"
    "{{\n"
    "  \"assignments\": [\n"
    "    {{\"step_index\": 0, \"executor\": \"executor_code\", \"reason\": \"简短理由\"}},\n"
    "    ...\n"
    "  ],\n"
    "  \"dependencies\": [\n"
    "    {{\"step_index\": 2, \"depends_on\": [0, 1], \"reason\": \"依赖原因\"}},\n"
    "    ...\n"
    "  ]\n"
    "}}\n"
    "\n"
    "计划步骤：\n{plan}\n"
    "\n"
    "artifacts：\n{artifacts}\n"
)


AGENT_REACT_REVIEW_REPAIR_PROMPT_TEMPLATE: Final = (
    "你正在执行一个本地 Agent 任务（ReAct）。\n"
    "当前执行遇到失败/卡住，需要根据 Eval Agent 的评估建议继续修复并完成目标。\n"
    "你只能输出 JSON（不要代码块、不要解释）。\n"
    "\n"
    "输出格式：\n"
    "{{\n"
    "  \"insert_steps\": [\n"
    "    {{\"title\":\"步骤标题\",\"brief\":\"简短总结\",\"allow\":[\"action_type\"]}},\n"
    "    ...\n"
    "  ]\n"
    "}}\n"
    "\n"
    "规则：\n"
    "1) insert_steps 数量为 1..{max_new_steps}。\n"
    "2) allow 只能从以下 action.type 中选择：{action_types_line}。\n"
    "3) brief 只写 2-10 个字（不要编号/不要标点/不要 URL）。\n"
    "4) insert_steps 不得包含 task_output；最终输出由原计划最后一步负责。\n"
    "4.1) 如确需追加输出步骤，必须先确认原计划没有 task_output。\n"
    "5) 如果 Eval Agent 指出“缺工具/没有真实执行/外部数据未获取”，insert_steps 必须补齐“工具自举 + 自测”链路：\n"
    "   - tool_call 创建/补全工具（带 tool_metadata.exec，output 留空让系统真实执行）\n"
    "   - tool_call 用一个最小输入自测（输出应非空且与目标相关）\n"
    "   - 再继续抓取/处理/总结，直到能 task_output 给出结果\n"
    "6) Windows 路径：python -c 中请使用正斜杠或 raw string（r'...')，避免 \\t/\\n 造成路径解析错误。\n"
    "\n"
    "用户目标：{message}\n"
    "当前 workdir：{workdir}\n"
    "实验目录（临时脚本/中间产物）：{agent_workspace}\n"
    "已有计划：{plan}\n"
    "已完成观测（最近几条，可能截断）：\n"
    "{observations}\n"
    "失败信息：{error}\n"
    "\n"
    "Eval Agent 评估（JSON，证据驱动）：\n"
    "- status: {review_status}\n"
    "- summary: {review_summary}\n"
    "- issues: {review_issues}\n"
    "- next_actions: {review_next_actions}\n"
    "\n"
    "可用工具列表（优先复用）：\n"
    "{tools}\n"
    "\n"
    "相关技能（可为空）：\n"
    "{skills}\n"
    "\n"
    "相关记忆（可为空）：\n"
    "{memories}\n"
    "\n"
    "相关知识图谱（可为空）：\n"
    "{graph}\n"
)


